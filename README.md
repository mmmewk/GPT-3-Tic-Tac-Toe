# GPT3 Tic Tac Toe

This is a react component in typescript that displays a game of tic-tac-toe. If any of the squares are clicked it will make a move. If a player wins the game it will display text notifying the user that they won. If the game is drawn it will display text notifying the user that it was a draw. There is a button to reset the game.

The game state is stored in local storage so that the game can be resumed later.

To run the game, open index.html in a browser.

Well that last bit was wrong... To run the game run `yarn start`

# Explaination

The above paragraph was generated by the GPT-3 AI. In addition the App.css and TicTacToe.tsx files in this project were completely written by the GPT-3.

In addition all debugging and revising of the code was done by GPT-3.
# GPT3 Prompt

Here is the prompt that generated the code. All code blocks were completely written by GPT3, the text outside of code blocks was the prompts that I gave it.

This is a react component in typescript that displays a game of tic-tac-toe. If any of the squares are clicked it will make a move. If a player wins the game it will display text notifying the user that they won. If the game is drawn it will display text notifying the user that it was a draw. There is a button to reset the game.

```typescript
import React from 'react';

const TicTacToe : React.FC = () => {
    const [gameState, setGameState] = React.useState({
        board: [
            [null, null, null],
            [null, null, null],
            [null, null, null]
        ],
        player: 'X',
        winner: null
    })

    const makeMove = (row: number, col: number) => {
        const board = gameState.board
        const player = gameState.player
        if (board[row][col] === null) {
            board[row][col] = player
            setGameState({
                board: board,
                player: player === 'X' ? 'O' : 'X',
                winner: checkWinner(board, player)
            })
        }
    }

    const checkWinner = (board: Array<Array<string | null>>, player: string) : string | null => {
        const winningLines = [
            [[0,0],[0,1],[0,2]],
            [[1,0],[1,1],[1,2]],
            [[2,0],[2,1],[2,2]],
            [[0,0],[1,0],[2,0]],
            [[0,1],[1,1],[2,1]],
            [[0,2],[1,2],[2,2]],
            [[0,0],[1,1],[2,2]],
            [[2,0],[1,1],[0,2]],
        ]

        for (let i=0; i < winningLines.length; i++) {
            const [[a1, b1], [a2, b2], [a3, b3]] = winningLines[i]
            if (board[a1][b1] === player && board[a2][b2] === player && board[a3][b3] === player) {
                return player
            }
        }
        return null
    }

    const resetGame = () => {
        setGameState({
            board: [
                [null, null, null],
                [null, null, null],
                [null, null, null]
            ],
            player: 'X',
            winner: null
        })
    }

    const renderSquare = (row: number, col: number) => {
        return (
            <button className="square" onClick={() => makeMove(row, col)}>
                {gameState.board[row][col]}
            </button>
        )
    }

    const renderBoard = () => {
        return (
            <div>
                <div className="board-row">
                    {renderSquare(0, 0)}
                    {renderSquare(0, 1)}
                    {renderSquare(0, 2)}
                </div>
                <div className="board-row">
                    {renderSquare(1, 0)}
                    {renderSquare(1, 1)}
                    {renderSquare(1, 2)}
                </div>
                <div className="board-row">
                    {renderSquare(2, 0)}
                    {renderSquare(2, 1)}
                    {renderSquare(2, 2)}
                </div>
            </div>
        )
    }

    const renderWinner = () => {
        return (
            <div>
                Winner: {gameState.winner}
            </div>
        )
    }

    const renderDraw = () => {
        return (
            <div>
                Draw
            </div>
        )
    }

    return (
        <div className="game">
            <div className="game-board">
                {renderBoard()}
            </div>
            <div className="game-info">
                {gameState.winner && renderWinner()}
                {gameState.winner === null && gameState.board.every(row => row.every(col => col !== null)) && renderDraw()}
                <button onClick={resetGame}>
                    Reset
                </button>
            </div>
        </div>
    );
}

export default TicTacToe;
```

This is a type definition for the above game state:

```typescript
interface GameState {
    board: Array<Array<string | null>>;
    player: string;
    winner: string | null;
}
```

This is a css file for the above game that centers the game on the page and makes the reset button look good:

```css
.game {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.game-board {
  width: 300px;
  height: 300px;
  border: 3px solid black;
}

.board-row {
  width: 100%;
  height: 100px;
  display: flex;
}

.square {
  width: 100px;
  height: 100px;
  border: 1px solid black;
  background-color: white;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 60px;
}

.game-info {
  margin-top: 20px;
}

.game-info > button {
  width: 100px;
  height: 50px;
  border: 2px solid black;
  background-color: lightgray;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 20px;
}
```

This is a function that saves the above game state to local storage:

```typescript
function saveGameState(gameState: GameState) {
    localStorage.setItem('gameState', JSON.stringify(gameState))
}

// This is a function that loads the game state from local storage:

function loadGameState() : GameState {
    const gameStateString = localStorage.getItem('gameState')
    if (gameStateString === null) {
        return {
            board: [
                [null, null, null],
                [null, null, null],
                [null, null, null]
            ],
            player: 'X',
            winner: null
        }
    }
    return JSON.parse(gameStateString)
}
```

This is an updated version of the above tic tac toe component that uses the above functions to store game state in local storage and uses the type definition for game state in the useState call:

```typescript
import React from 'react';

const TicTacToe : React.FC = () => {
    const [gameState, setGameState] = React.useState<GameState>(loadGameState())

    const makeMove = (row: number, col: number) => {
        const board = gameState.board
        const player = gameState.player
        if (board[row][col] === null) {
            board[row][col] = player
            const newGameState = {
                board: board,
                player: player === 'X' ? 'O' : 'X',
                winner: checkWinner(board, player)
            }
            setGameState(newGameState)
            saveGameState(newGameState)
        }
    }

    const checkWinner = (board: Array<Array<string | null>>, player: string) : string | null => {
        const winningLines = [
            [[0,0],[0,1],[0,2]],
            [[1,0],[1,1],[1,2]],
            [[2,0],[2,1],[2,2]],
            [[0,0],[1,0],[2,0]],
            [[0,1],[1,1],[2,1]],
            [[0,2],[1,2],[2,2]],
            [[0,0],[1,1],[2,2]],
            [[2,0],[1,1],[0,2]],
        ]

        for (let i=0; i < winningLines.length; i++) {
            const [[a1, b1], [a2, b2], [a3, b3]] = winningLines[i]
            if (board[a1][b1] === player && board[a2][b2] === player && board[a3][b3] === player) {
                return player
            }
        }
        return null
    }

    const resetGame = () => {
        setGameState({
            board: [
                [null, null, null],
                [null, null, null],
                [null, null, null]
            ],
            player: 'X',
            winner: null
        })
        saveGameState({
            board: [
                [null, null, null],
                [null, null, null],
                [null, null, null]
            ],
            player: 'X',
            winner: null
        })
    }

    const renderSquare = (row: number, col: number) => {
        return (
            <button className="square" onClick={() => makeMove(row, col)}>
                {gameState.board[row][col]}
            </button>
        )
    }

    const renderBoard = () => {
        return (
            <div>
                <div className="board-row">
                    {renderSquare(0, 0)}
                    {renderSquare(0, 1)}
                    {renderSquare(0, 2)}
                </div>
                <div className="board-row">
                    {renderSquare(1, 0)}
                    {renderSquare(1, 1)}
                    {renderSquare(1, 2)}
                </div>
                <div className="board-row">
                    {renderSquare(2, 0)}
                    {renderSquare(2, 1)}
                    {renderSquare(2, 2)}
                </div>
            </div>
        )
    }

    const renderWinner = () => {
        return (
            <div>
                Winner: {gameState.winner}
            </div>
        )
    }

    const renderDraw = () => {
        return (
            <div>
                Draw
            </div>
        )
    }

    return (
        <div className="game">
            <div className="game-board">
                {renderBoard()}
            </div>
            <div className="game-info">
                {gameState.winner && renderWinner()}
                {gameState.winner === null && gameState.board.every(row => row.every(col => col !== null)) && renderDraw()}
                <button onClick={resetGame}>
                    Reset
                </button>
            </div>
        </div>
    );
}

export default TicTacToe;
```

This is a description of how to cause a bug in the above game:

```
To cause a bug in the game, you can try to make a move when the game is over. For example, if X has won the game and you try to make a move as O, the game will still register the move for O.
```

rewrite the makeMove function to fix the above bug:

```typescript
const makeMove = (row: number, col: number) => {
    const board = gameState.board
    const player = gameState.player
    if (gameState.winner === null && board[row][col] === null) {
        board[row][col] = player
        const newGameState = {
            board: board,
            player: player === 'X' ? 'O' : 'X',
            winner: checkWinner(board, player)
        }
        setGameState(newGameState)
        saveGameState(newGameState)
    }
}
```

This is a readme for the above project:

```
This is a react component in typescript that displays a game of tic-tac-toe. If any of the squares are clicked it will make a move. If a player wins the game it will display text notifying the user that they won. If the game is drawn it will display text notifying the user that it was a draw. There is a button to reset the game.

The game state is stored in local storage so that the game can be resumed later.

To run the game, open index.html in a browser.
```

This is an updated version of the above  component that tracks how many games X has won, how many games O has won and how many games are drawn:

```typescript
import React from 'react';

interface GameState {
  board: Array<Array<string | null>>;
  player: string;
  winner: string | null;
  numXWins: number;
  numOWins: number;
  numDraws: number;
}

function saveGameState(gameState: GameState) {
  localStorage.setItem('gameState', JSON.stringify(gameState))
}

function loadGameState() : GameState {
  const gameStateString = localStorage.getItem('gameState')
  if (gameStateString === null) {
      return {
          board: [
              [null, null, null],
              [null, null, null],
              [null, null, null]
          ],
          player: 'X',
          winner: null,
          numXWins: 0,
          numOWins: 0,
          numDraws: 0
      }
  }
  return JSON.parse(gameStateString)
}

const TicTacToe : React.FC = () => {
    const [gameState, setGameState] = React.useState<GameState>(loadGameState())

    const makeMove = (row: number, col: number) => {
      const board = gameState.board
      const player = gameState.player
      if (board[row][col] === null && gameState.winner === null) {
          board[row][col] = player
          const newGameState = {
              board: board,
              player: player === 'X' ? 'O' : 'X',
              winner: checkWinner(board, player),
              numXWins: gameState.numXWins,
              numOWins: gameState.numOWins,
              numDraws: gameState.numDraws
          }
          if (newGameState.winner === 'X') {
              newGameState.numXWins = gameState.numXWins + 1
          }
          if (newGameState.winner === 'O') {
              newGameState.numOWins = gameState.numOWins + 1
          }
          if (newGameState.winner === null && newGameState.board.every(row => row.every(col => col !== null))) {
              newGameState.numDraws = gameState.numDraws + 1
          }
          setGameState(newGameState)
          saveGameState(newGameState)
      }
  }

    const checkWinner = (board: Array<Array<string | null>>, player: string) : string | null => {
        const winningLines = [
            [[0,0],[0,1],[0,2]],
            [[1,0],[1,1],[1,2]],
            [[2,0],[2,1],[2,2]],
            [[0,0],[1,0],[2,0]],
            [[0,1],[1,1],[2,1]],
            [[0,2],[1,2],[2,2]],
            [[0,0],[1,1],[2,2]],
            [[2,0],[1,1],[0,2]],
        ]

        for (let i=0; i < winningLines.length; i++) {
            const [[a1, b1], [a2, b2], [a3, b3]] = winningLines[i]
            if (board[a1][b1] === player && board[a2][b2] === player && board[a3][b3] === player) {
                return player
            }
        }
        return null
    }

    const resetGame = () => {
        setGameState({
            board: [
                [null, null, null],
                [null, null, null],
                [null, null, null]
            ],
            player: 'X',
            winner: null,
            numXWins: gameState.numXWins,
            numOWins: gameState.numOWins,
            numDraws: gameState.numDraws
        })
        saveGameState({
            board: [
                [null, null, null],
                [null, null, null],
                [null, null, null]
            ],
            player: 'X',
            winner: null,
            numXWins: gameState.numXWins,
            numOWins: gameState.numOWins,
            numDraws: gameState.numDraws
        })
    }

    const renderSquare = (row: number, col: number) => {
        return (
            <button className="square" onClick={() => makeMove(row, col)}>
                {gameState.board[row][col]}
            </button>
        )
    }

    const renderBoard = () => {
        return (
            <div>
                <div className="board-row">
                    {renderSquare(0, 0)}
                    {renderSquare(0, 1)}
                    {renderSquare(0, 2)}
                </div>
                <div className="board-row">
                    {renderSquare(1, 0)}
                    {renderSquare(1, 1)}
                    {renderSquare(1, 2)}
                </div>
                <div className="board-row">
                    {renderSquare(2, 0)}
                    {renderSquare(2, 1)}
                    {renderSquare(2, 2)}
                </div>
            </div>
        )
    }

    const renderWinner = () => {
        return (
            <div>
                Winner: {gameState.winner}
            </div>
        )
    }

    const renderDraw = () => {
        return (
            <div>
                Draw
            </div>
        )
    }

    const renderStats = () => {
        return (
            <div>
                <div>
                    X wins: {gameState.numXWins}
                </div>
                <div>
                    O wins: {gameState.numOWins}
                </div>
                <div>
                    Draws: {gameState.numDraws}
                </div>
            </div>
        )
    }

    return (
        <div className="game">
            <div className="game-board">
                {renderBoard()}
            </div>
            <div className="game-info">
                {renderStats()}
                {gameState.winner && renderWinner()}
                {gameState.winner === null && gameState.board.every(row => row.every(col => col !== null)) && renderDraw()}
                <button onClick={resetGame}>
                    Reset
                </button>
            </div>
        </div>
    );
}

export default TicTacToe;
```

this is a css file that positions the game info absolutely on the top right corner of the screen inside a box with a faint box-shadow and a small margin from the right and top edges of the screen and adds some space above the reset button:

```css
.game-info {
  position: absolute;
  top: 0;
  right: 0;
  margin: 2px;
  padding: 2px;
  color: #555;
  font-size: 85%;
  line-height: 130%;
  box-shadow: 0 0 5px 1px #aaa;
  border: 1px solid #aaa;
}

.game-info:before {
  content: 'Game info';
  display: block;
  font-size: 75%;
  margin-bottom: 5px;
}

.game-info button {
  margin-top: 10px;
}
```

this is a css file that rounds the corners of the reset button and adds some colors to the rest button:

```css
.game-info button {
  border: none;
  border-radius: 5px;
  background-color: gold;
  color: #555;
  cursor: pointer;
  padding: 5px 10px;
  line-height: 1;
}

.game-info button:hover {
  background-color: orange;
}

.game-info button:active {
  background-color: red;
}
```

Write a typescript function that takes a tic tac toe game state of this type:

interface GameState {
  board: Array<Array<string | null>>;
  player: string;
  winner: string | null;
  numXWins: number;
  numOWins: number;
  numDraws: number;
}

and outputs the row and column of the next best move:

```typescript
function getNextMove(gameState: GameState): {row: number, column: number} {
  //TODO
}
```

what is the problem with the above function?

```
There is no return type specified for the getNextMove function.
```

rewrite the function to address that issue.

```typescript
function getNextMove(gameState: GameState): {row: number, column: number} {
  //TODO
  return {row: 0, column: 0};
}
```

Update the above function to only return valid moves for the game tic tac toe:

```typescript
function getNextMove(gameState: GameState): {row: number, column: number} {
  //TODO
  for (let row = 0; row < gameState.board.length; row++) {
    for (let column = 0; column < gameState.board[row].length; column++) {
      if (gameState.board[row][column] === null) {
        return {row: row, column: column};
      }
    }
  }
  return null;
}
```

Update the above function to make a winning move if possible:

```typescript
function getNextMove(gameState: GameState): {row: number, column: number} {
  //TODO
  for (let row = 0; row < gameState.board.length; row++) {
    for (let column = 0; column < gameState.board[row].length; column++) {
      if (gameState.board[row][column] === null) {
        //check if move is winning move
        if (
          (row === 0 &&
            gameState.board[1][column] === gameState.player &&
            gameState.board[2][column] === gameState.player) ||
          (row === 1 &&
            gameState.board[0][column] === gameState.player &&
            gameState.board[2][column] === gameState.player) ||
          (row === 2 &&
            gameState.board[0][column] === gameState.player &&
            gameState.board[1][column] === gameState.player) ||
          (column === 0 &&
            gameState.board[row][1] === gameState.player &&
            gameState.board[row][2] === gameState.player) ||
          (column === 1 &&
            gameState.board[row][0] === gameState.player &&
            gameState.board[row][2] === gameState.player) ||
          (column === 2 &&
            gameState.board[row][0] === gameState.player &&
            gameState.board[row][1] === gameState.player) ||
          (row === column &&
            gameState.board[0][0] === gameState.player &&
            gameState.board[1][1] === gameState.player &&
            gameState.board[2][2] === gameState.player) ||
          (row + column === 2 &&
            gameState.board[0][2] === gameState.player &&
            gameState.board[1][1] === gameState.player &&
            gameState.board[2][0] === gameState.player)
        ) {
          return {row: row, column: column};
        }
      }
    }
  }
  return null;
}
```

Update the function to otherwise block the other player from winning:

```typescript
function getNextMove(gameState: GameState): {row: number, column: number} {
  //TODO
  for (let row = 0; row < gameState.board.length; row++) {
    for (let column = 0; column < gameState.board[row].length; column++) {
      if (gameState.board[row][column] === null) {
        //check if move is winning move
        if (
          (row === 0 &&
            gameState.board[1][column] === gameState.player &&
            gameState.board[2][column] === gameState.player) ||
          (row === 1 &&
            gameState.board[0][column] === gameState.player &&
            gameState.board[2][column] === gameState.player) ||
          (row === 2 &&
            gameState.board[0][column] === gameState.player &&
            gameState.board[1][column] === gameState.player) ||
          (column === 0 &&
            gameState.board[row][1] === gameState.player &&
            gameState.board[row][2] === gameState.player) ||
          (column === 1 &&
            gameState.board[row][0] === gameState.player &&
            gameState.board[row][2] === gameState.player) ||
          (column === 2 &&
            gameState.board[row][0] === gameState.player &&
            gameState.board[row][1] === gameState.player) ||
          (row === column &&
            gameState.board[0][0] === gameState.player &&
            gameState.board[1][1] === gameState.player &&
            gameState.board[2][2] === gameState.player) ||
          (row + column === 2 &&
            gameState.board[0][2] === gameState.player &&
            gameState.board[1][1] === gameState.player &&
            gameState.board[2][0] === gameState.player)
        ) {
          return {row: row, column: column};
        }
        //check if move blocks other player from winning
        if (
          (row === 0 &&
            gameState.board[1][column] === gameState.player &&
            gameState.board[2][column] === gameState.player) ||
          (row === 1 &&
            gameState.board[0][column] === gameState.player &&
            gameState.board[2][column] === gameState.player) ||
          (row === 2 &&
            gameState.board[0][column] === gameState.player &&
            gameState.board[1][column] === gameState.player) ||
          (column === 0 &&
            gameState.board[row][1] === gameState.player &&
            gameState.board[row][2] === gameState.player) ||
          (column === 1 &&
            gameState.board[row][0] === gameState.player &&
            gameState.board[row][2] === gameState.player) ||
          (column === 2 &&
            gameState.board[row][0] === gameState.player &&
            gameState.board[row][1] === gameState.player) ||
          (row === column &&
            gameState.board[0][0] === gameState.player &&
            gameState.board[1][1] === gameState.player &&
            gameState.board[2][2] === gameState.player) ||
          (row + column === 2 &&
            gameState.board[0][2] === gameState.player &&
            gameState.board[1][1] === gameState.player &&
            gameState.board[2][0] === gameState.player)
        ) {
          return {row: row, column: column};
        }
      }
    }
  }
  return null;
}
```

what is wrong with the above function?

```
The function does not check if the game is over before making a move.
```

rewrite the function to address that issue.

```typescript
function getNextMove(gameState: GameState): {row: number, column: number} {
  //TODO
  if (gameState.winner === null) {
    for (let row = 0; row < gameState.board.length; row++) {
      for (let column = 0; column < gameState.board[row].length; column++) {
        if (gameState.board[row][column] === null) {
          //check if move is winning move
          if (
            (row === 0 &&
              gameState.board[1][column] === gameState.player &&
              gameState.board[2][column] === gameState.player) ||
            (row === 1 &&
              gameState.board[0][column] === gameState.player &&
              gameState.board[2][column] === gameState.player) ||
            (row === 2 &&
              gameState.board[0][column] === gameState.player &&
              gameState.board[1][column] === gameState.player) ||
            (column === 0 &&
              gameState.board[row][1] === gameState.player &&
              gameState.board[row][2] === gameState.player) ||
            (column === 1 &&
              gameState.board[row][0] === gameState.player &&
              gameState.board[row][2] === gameState.player) ||
            (column === 2 &&
              gameState.board[row][0] === gameState.player &&
              gameState.board[row][1] === gameState.player) ||
            (row === column &&
              gameState.board[0][0] === gameState.player &&
              gameState.board[1][1] === gameState.player &&
              gameState.board[2][2] === gameState.player) ||
            (row + column === 2 &&
              gameState.board[0][2] === gameState.player &&
              gameState.board[1][1] === gameState.player &&
              gameState.board[2][0] === gameState.player)
          ) {
            return {row: row, column: column};
          }
          //check if move blocks other player from winning
          if (
            (row === 0 &&
              gameState.board[1][column] === gameState.player &&
              gameState.board[2][column] === gameState.player) ||
            (row === 1 &&
              gameState.board[0][column] === gameState.player &&
              gameState.board[2][column] === gameState.player) ||
            (row === 2 &&
              gameState.board[0][column] === gameState.player &&
              gameState.board[1][column] === gameState.player) ||
            (column === 0 &&
              gameState.board[row][1] === gameState.player &&
              gameState.board[row][2] === gameState.player) ||
            (column === 1 &&
              gameState.board[row][0] === gameState.player &&
              gameState.board[row][2] === gameState.player) ||
            (column === 2 &&
              gameState.board[row][0] === gameState.player &&
              gameState.board[row][1] === gameState.player) ||
            (row === column &&
              gameState.board[0][0] === gameState.player &&
              gameState.board[1][1] === gameState.player &&
              gameState.board[2][2] === gameState.player) ||
            (row + column === 2 &&
              gameState.board[0][2] === gameState.player &&
              gameState.board[1][1] === gameState.player &&
              gameState.board[2][0] === gameState.player)
          ) {
            return {row: row, column: column};
          }
        }
      }
    }
  }
  return null;
}
```

what is wrong with the return type of the function?

```
The return type of the function is specified as {row: number, column: number} but the function returns null if there are no valid moves.
```

rewrite the function to address that issue.

```typescript
function getNextMove(gameState: GameState): {row: number, column: number} | null {
  //TODO
  if (gameState.winner === null) {
    for (let row = 0; row < gameState.board.length; row++) {
      for (let column = 0; column < gameState.board[row].length; column++) {
        if (gameState.board[row][column] === null) {
          //check if move is winning move
          if (
            (row === 0 &&
              gameState.board[1][column] === gameState.player &&
              gameState.board[2][column] === gameState.player) ||
            (row === 1 &&
              gameState.board[0][column] === gameState.player &&
              gameState.board[2][column] === gameState.player) ||
            (row === 2 &&
              gameState.board[0][column] === gameState.player &&
              gameState.board[1][column] === gameState.player) ||
            (column === 0 &&
              gameState.board[row][1] === gameState.player &&
              gameState.board[row][2] === gameState.player) ||
            (column === 1 &&
              gameState.board[row][0] === gameState.player &&
              gameState.board[row][2] === gameState.player) ||
            (column === 2 &&
              gameState.board[row][0] === gameState.player &&
              gameState.board[row][1] === gameState.player) ||
            (row === column &&
              gameState.board[0][0] === gameState.player &&
              gameState.board[1][1] === gameState.player &&
              gameState.board[2][2] === gameState.player) ||
            (row + column === 2 &&
              gameState.board[0][2] === gameState.player &&
              gameState.board[1][1] === gameState.player &&
              gameState.board[2][0] === gameState.player)
          ) {
            return {row: row, column: column};
          }
          //check if move blocks other player from winning
          if (
            (row === 0 &&
              gameState.board[1][column] === gameState.player &&
              gameState.board[2][column] === gameState.player) ||
            (row === 1 &&
              gameState.board[0][column] === gameState.player &&
              gameState.board[2][column] === gameState.player) ||
            (row === 2 &&
              gameState.board[0][column] === gameState.player &&
              gameState.board[1][column] === gameState.player) ||
            (column === 0 &&
              gameState.board[row][1] === gameState.player &&
              gameState.board[row][2] === gameState.player) ||
            (column === 1 &&
              gameState.board[row][0] === gameState.player &&
              gameState.board[row][2] === gameState.player) ||
            (column === 2 &&
              gameState.board[row][0] === gameState.player &&
              gameState.board[row][1] === gameState.player) ||
            (row === column &&
              gameState.board[0][0] === gameState.player &&
              gameState.board[1][1] === gameState.player &&
              gameState.board[2][2] === gameState.player) ||
            (row + column === 2 &&
              gameState.board[0][2] === gameState.player &&
              gameState.board[1][1] === gameState.player &&
              gameState.board[2][0] === gameState.player)
          ) {
            return {row: row, column: column};
          }
        }
      }
    }
  }
  return null;
}
```

# TODO

get it to use the getNextMove function to play for O
